#ifndef INC_HSTopicBase_H
#define INC_HSTopicBase_H

// WARNING: This file has been generated by D3. You should NEVER change this file.
//          Please refer to the documentation of MetaEntity::CreateSpecialisedCPPHeader()
//          which explains in detail how you can gegenerate this file.
//
// The file declares methods which simplify client interactions with objects of type 
// HSTopic representing instances of D3HSDB.HSTopic.
//
//       For D3 to work correctly, you must implement your own class as follows:
//
//       #include "HSTopicBase.h"
//
//       namespace D3
//       {
//         class HSTopic : public HSTopicBase
//         {
//           D3_CLASS_DECL(HSTopic);
//
//           protected:
//             HSTopic() {}
//
//           public:
//             ~HSTopic() {}
//
//             // Insert your specialised member functions here...
//
//         };
//       } // end namespace D3
//

#include "Entity.h"
#include "Column.h"
#include "Key.h"
#include "Relation.h"
#include "D3HSDB.h"

namespace D3
{

	//! Use these enums to access columns through HSTopic::Column() method
	enum HSTopic_Fields
	{
		HSTopic_ID,
		HSTopic_Title,
		HSTopic_MarkupText,
		HSTopic_PlainText,
		HSTopic_Targets
	};


	//! HSTopicBase is a base class that \b MUST be subclassed through a class called \a HSTopic.
	/*! The purpose of this class to provide more natural access to related objects as well as this' columns.
			This class is only usefull if it is subclassed by a class called HSTopic
			Equally important is that the meta dictionary knows of the existence of your subclass as well as
			specialised Relation classes implemented herein. Only once these details have been added to the
			dictionary will D3 instantiate objects of type \a HSTopic representing rows from the table \a D3HSDB.HSTopic.
	*/
	class D3_API HSTopicBase: public Entity
	{
		D3_CLASS_DECL(HSTopicBase);

		public:
			//! Enable iterating over all instances of this
			class D3_API iterator : public InstanceKeyPtrSetItr
			{
				public:
					iterator() {}
					iterator(const InstanceKeyPtrSetItr& itr) : InstanceKeyPtrSetItr(itr) {}

					//! De-reference operator*()
					virtual HSTopicPtr              operator*();
					//! Assignment operator=()
					virtual iterator&               operator=(const iterator& itr);
			};

			static unsigned int                 size(DatabasePtr pDB)         { return GetAll(pDB)->size(); }
			static bool                         empty(DatabasePtr pDB)        { return GetAll(pDB)->empty(); }
			static iterator                     begin(DatabasePtr pDB)        { return iterator(GetAll(pDB)->begin()); }
			static iterator                     end(DatabasePtr pDB)          { return iterator(GetAll(pDB)->end()); }

			//! Enable iterating the relation ChildTopics to access related HSTopicAssociation objects
			class D3_API ChildTopics : public Relation
			{
				D3_CLASS_DECL(ChildTopics);

				protected:
					ChildTopics() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSTopicAssociationPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSTopicAssociationPtr   front();
					//! back() method
					virtual HSTopicAssociationPtr   back();
			};

			//! Enable iterating the relation ParentTopics to access related HSTopicAssociation objects
			class D3_API ParentTopics : public Relation
			{
				D3_CLASS_DECL(ParentTopics);

				protected:
					ParentTopics() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSTopicAssociationPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSTopicAssociationPtr   front();
					//! back() method
					virtual HSTopicAssociationPtr   back();
			};

			//! Enable iterating the relation LinksToTopics to access related HSTopicLink objects
			class D3_API LinksToTopics : public Relation
			{
				D3_CLASS_DECL(LinksToTopics);

				protected:
					LinksToTopics() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSTopicLinkPtr      operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSTopicLinkPtr          front();
					//! back() method
					virtual HSTopicLinkPtr          back();
			};

			//! Enable iterating the relation LinkedFromTopics to access related HSTopicLink objects
			class D3_API LinkedFromTopics : public Relation
			{
				D3_CLASS_DECL(LinkedFromTopics);

				protected:
					LinkedFromTopics() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSTopicLinkPtr      operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSTopicLinkPtr          front();
					//! back() method
					virtual HSTopicLinkPtr          back();
			};

			//! Enable iterating the relation ResourceUsages to access related HSResourceUsage objects
			class D3_API ResourceUsages : public Relation
			{
				D3_CLASS_DECL(ResourceUsages);

				protected:
					ResourceUsages() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSResourceUsagePtr  operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSResourceUsagePtr      front();
					//! back() method
					virtual HSResourceUsagePtr      back();
			};

			//! Enable iterating the relation MetaDatabases to access related HSMetaDatabaseTopic objects
			class D3_API MetaDatabases : public Relation
			{
				D3_CLASS_DECL(MetaDatabases);

				protected:
					MetaDatabases() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSMetaDatabaseTopicPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSMetaDatabaseTopicPtr  front();
					//! back() method
					virtual HSMetaDatabaseTopicPtr  back();
			};

			//! Enable iterating the relation MetaEntities to access related HSMetaEntityTopic objects
			class D3_API MetaEntities : public Relation
			{
				D3_CLASS_DECL(MetaEntities);

				protected:
					MetaEntities() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSMetaEntityTopicPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSMetaEntityTopicPtr    front();
					//! back() method
					virtual HSMetaEntityTopicPtr    back();
			};

			//! Enable iterating the relation MetaColumns to access related HSMetaColumnTopic objects
			class D3_API MetaColumns : public Relation
			{
				D3_CLASS_DECL(MetaColumns);

				protected:
					MetaColumns() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSMetaColumnTopicPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSMetaColumnTopicPtr    front();
					//! back() method
					virtual HSMetaColumnTopicPtr    back();
			};

			//! Enable iterating the relation MetaKeys to access related HSMetaKeyTopic objects
			class D3_API MetaKeys : public Relation
			{
				D3_CLASS_DECL(MetaKeys);

				protected:
					MetaKeys() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSMetaKeyTopicPtr   operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSMetaKeyTopicPtr       front();
					//! back() method
					virtual HSMetaKeyTopicPtr       back();
			};

			//! Enable iterating the relation MetaRelations to access related HSMetaRelationTopic objects
			class D3_API MetaRelations : public Relation
			{
				D3_CLASS_DECL(MetaRelations);

				protected:
					MetaRelations() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual HSMetaRelationTopicPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual HSMetaRelationTopicPtr  front();
					//! back() method
					virtual HSMetaRelationTopicPtr  back();
			};



		protected:
			HSTopicBase() {}

		public:
			~HSTopicBase() {}

			//! Create a new HSTopic
			static HSTopicPtr                   CreateHSTopic(DatabasePtr pDB)		{ return (HSTopicPtr) pDB->GetMetaDatabase()->GetMetaEntity(D3HSDB_HSTopic)->CreateInstance(pDB); }

			//! Return a collection of all instances of this
			static InstanceKeyPtrSetPtr					GetAll(DatabasePtr pDB);

			//! Load all instances of this
			static void													LoadAll(DatabasePtr pDB, bool bRefresh = false, bool bLazyFetch = true);

			//! Load a particular instance of this
			static HSTopicPtr                   Load(DatabasePtr pDB, long lID, bool bRefresh = false, bool bLazyFetch = true);


			//! Load all ChildTopics objects. The objects loaded are of type HSTopicAssociation.
			virtual void												LoadAllChildTopics(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation ChildTopics collection which contains objects of type HSTopicAssociation.
			virtual ChildTopics*                GetChildTopics();
			//! Load all ParentTopics objects. The objects loaded are of type HSTopicAssociation.
			virtual void												LoadAllParentTopics(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation ParentTopics collection which contains objects of type HSTopicAssociation.
			virtual ParentTopics*               GetParentTopics();
			//! Load all LinksToTopics objects. The objects loaded are of type HSTopicLink.
			virtual void												LoadAllLinksToTopics(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation LinksToTopics collection which contains objects of type HSTopicLink.
			virtual LinksToTopics*              GetLinksToTopics();
			//! Load all LinkedFromTopics objects. The objects loaded are of type HSTopicLink.
			virtual void												LoadAllLinkedFromTopics(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation LinkedFromTopics collection which contains objects of type HSTopicLink.
			virtual LinkedFromTopics*           GetLinkedFromTopics();
			//! Load all ResourceUsages objects. The objects loaded are of type HSResourceUsage.
			virtual void												LoadAllResourceUsages(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation ResourceUsages collection which contains objects of type HSResourceUsage.
			virtual ResourceUsages*             GetResourceUsages();
			//! Load all MetaDatabases objects. The objects loaded are of type HSMetaDatabaseTopic.
			virtual void												LoadAllMetaDatabases(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation MetaDatabases collection which contains objects of type HSMetaDatabaseTopic.
			virtual MetaDatabases*              GetMetaDatabases();
			//! Load all MetaEntities objects. The objects loaded are of type HSMetaEntityTopic.
			virtual void												LoadAllMetaEntities(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation MetaEntities collection which contains objects of type HSMetaEntityTopic.
			virtual MetaEntities*               GetMetaEntities();
			//! Load all MetaColumns objects. The objects loaded are of type HSMetaColumnTopic.
			virtual void												LoadAllMetaColumns(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation MetaColumns collection which contains objects of type HSMetaColumnTopic.
			virtual MetaColumns*                GetMetaColumns();
			//! Load all MetaKeys objects. The objects loaded are of type HSMetaKeyTopic.
			virtual void												LoadAllMetaKeys(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation MetaKeys collection which contains objects of type HSMetaKeyTopic.
			virtual MetaKeys*                   GetMetaKeys();
			//! Load all MetaRelations objects. The objects loaded are of type HSMetaRelationTopic.
			virtual void												LoadAllMetaRelations(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation MetaRelations collection which contains objects of type HSMetaRelationTopic.
			virtual MetaRelations*              GetMetaRelations();

			/*! @name Get Column Values
			    \note These accessors do not throw even if the column's value is NULL.
			           Therefore, you should use these methods only if you're sure the
			           column's value is NOT NULL before using these.
			*/
			//@{
			//! ID
			virtual long                        GetID()                        { return Column(HSTopic_ID)->GetLong(); }
			//! Title
			virtual const std::string&          GetTitle()                     { return Column(HSTopic_Title)->GetString(); }
			//! MarkupText
			virtual const std::stringstream&    GetMarkupText()                { return Column(HSTopic_MarkupText)->GetBlob(); }
			//! PlainText
			virtual const std::string&          GetPlainText()                 { return Column(HSTopic_PlainText)->GetString(); }
			//! Targets
			virtual long                        GetTargets()                   { return Column(HSTopic_Targets)->GetLong(); }
			//@}

			/*! @name Set Column Values
			*/
			//@{
			//! Set ID
			virtual bool												SetID(long val)                { return Column(HSTopic_ID)->SetValue(val); }
			//! Set Title
			virtual bool												SetTitle(const std::string& val){ return Column(HSTopic_Title)->SetValue(val); }
			//! Set MarkupText
			virtual bool												SetMarkupText(const std::stringstream& val){ return Column(HSTopic_MarkupText)->SetValue(val); }
			//! Set PlainText
			virtual bool												SetPlainText(const std::string& val){ return Column(HSTopic_PlainText)->SetValue(val); }
			//! Set Targets
			virtual bool												SetTargets(long val)           { return Column(HSTopic_Targets)->SetValue(val); }
			//@}

			//! A column accessor provided mainly for backwards compatibility
			virtual ColumnPtr										Column(HSTopic_Fields eCol){ return Entity::GetColumn((unsigned int) eCol); }
	};



} // end namespace D3


#endif /* INC_HSTopicBase_H */
