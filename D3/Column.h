#ifndef INC_D3_COLUMN_H_
#define INC_D3_COLUMN_H_

// ===========================================================
// File Info:
//
// $Author: lalit $
// $Date: 2014/12/29 08:32:40 $
// $Revision: 1.47 $
//
// MetaColumn: This class describes a column of any of
// the ap3/t3 classes.
//
// ===========================================================
// Change History:
// ===========================================================
//
// 09/10/02 - R1 - Hugp
//
// Changes required to accomodate extended attributes as
// implemented by APAL3ActivityType and APAL3Activity:
//
// - Allow base columns to live without m_pEntity
// - Store column names as strings
//
// -----------------------------------------------------------

#include "D3.h"
#include "D3MDDB.h"
#include "D3BitMask.h"
#include "D3Date.h"
#include "D3Funcs.h"

// Needs JSON
#include <json/json.h>
#include "OTLParams.h"

extern const char szMetaColumnFlags[];					// solely used to ensure type safety (no implementation needed)
extern const char szMetaColumnPermissions[];		// solely used to ensure type safety (no implementation needed)

namespace D3
{
	//! The Data class can be used to manage simple binary data
	class D3_API Data
	{
		protected:
			unsigned char*	m_pBuf;				//!< The buffer holding the binary data
			unsigned int		m_iLen;				//!< the length of the data stored

		public:
			//! Default ctor
			Data() : m_iLen(0), m_pBuf(NULL) {}

			//! This constructor expects a raw buffer and a length to be passed in
			Data(const unsigned char* p, unsigned int l) : m_iLen(0), m_pBuf(NULL) { assign(p, l); }

			//! Copy constructor
			Data(const Data& data) : m_iLen(0), m_pBuf(NULL) { assign(data.m_pBuf, data.m_iLen); }

			//! Constructor allocates a buffer of size l initialized with \0
			Data(unsigned int l);

			//! Public dtor deallocates internal resources
			~Data()		{	delete [] m_pBuf;	}

			//! typecast operator allows this to be used in other standard C functions
			operator const unsigned char*	() const				{ return m_pBuf; }

			//! you can use this to write data to the internal buffer, but make sure you don't write more than getLength() bytes!
			unsigned char*				buffer()								{ return m_pBuf; }

			//! Return the size of the data currenly stored
			unsigned int								length() const					{ return m_iLen; }

			//! compare the data of this with the data in external buffer
			int										compare(unsigned char* p, unsigned int l) const;

			//! compare this with the another Dasta object (0==same, -1=this is less, 1=this is greater)
			int										compare(const Data& data) const				{	return compare(data.m_pBuf, data.m_iLen);	}

			//! return true if this is the same as the other Data object
			bool									operator==(const Data& data) const	{ return this->compare(data) == 0; }

			//! assign data from a buffer
			void									assign(const unsigned char* p, unsigned int l);

			//! assign data from a buffer
			void									operator=(const Data& data)	{ assign(data.m_pBuf, data.m_iLen); }

			//! Return this as a base64 encoded string
			std::string						base64_encode() const;

			//! attempts to set this' value from a base 64 encoded input string
			void									base64_decode(const std::string& strEncodedData);
	};



	//! We store all MetaColumn objects in a map keyed by ID
	/*! Note that objects which are not stored in the meta dictionary (e.g. MetaColumn objects
			created at system startup to enable access to the the MetaDictionary database)
			are assigned MetaColumn::M_uNextInternalID which is then decremented by 1. The
			initial value	of MetaColumn::M_uNextInternalID is COLUMN_ID_MAX.
			MetaColumn objects without a physical representation on disk are therefore
			identifiable if GetID() returns a value > MetaColumn::M_uNextInternalID.
	*/
	typedef std::map< ColumnID, MetaColumnPtr >				MetaColumnPtrMap;
	typedef MetaColumnPtrMap::iterator								MetaColumnPtrMapItr;

	//! The MetaColumn class is an abstract class which implements generic behaviour and properties for a column type
	/*! Every single column type in a database will be represented inside D3 with an instance of a class which is ako MetaColumn.
	*/
	class D3_API MetaColumn : public Object
	{
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;
		friend class ODBCDatabase;
		friend class OTLDatabase;

		D3_CLASS_DECL_PV(MetaColumn);

		public:
			//! The Flags bitmask identifies basic characteristics for each column definition
			struct Flags : public Bits<szMetaColumnFlags>
			{
				BITS_DECL(MetaColumn, Flags);

				//@{ Primitive masks
				static const Mask Mandatory;					//!< 0x00000004 - Column can't be NULL
				static const Mask AutoNum;						//!< 0x00000008 - Column's value is generated by the RDBMS
				static const Mask Derived;						//!< 0x00000010 - The column has no representation in the database

				static const Mask SingleChoice;				//!< 0x00000040 - This is a column with a predefined set of values and only one can apply
				static const Mask MultiChoice;				//!< 0x00000080 - This is a column with a predefined set of values and zero to many of those can apply
				static const Mask LazyFetch;					//!< 0x00000100 - Column is lazy fetched (not fetched until explicitely requested)
				static const Mask Password;						//!< 0x00000020 - Column is a password column (ignored if column is not of type string)
				static const Mask EncodedValue;				//!< 0x00000400 - Only relevant if the column is a string or blob. If this flag is set, the value is will be returned as a base64 encoded string

				static const Mask HiddenOnDetailView;	//!< 0x00000002 - Column will be hidden from entity detail views
				static const Mask HiddenOnListView;		//!< 0x00000200 - Column will be hidden from entity list views
				//@}

				//@{ Combo masks
				static const Mask Default;						//!< 0x00000000 - Nothing set is the default
				static const Mask	Hidden;							//!< same as HiddenOnDetailView | HiddenOnListView
				//@}
			};


			//! The Permissions bitmask identifies basic permissions for column definition
			struct Permissions : public Bits<szMetaColumnPermissions>
			{
				BITS_DECL(MetaColumn, Permissions);

				//@{ Primitive masks
				static const Mask Read;							//!< 0x00000001 - Column can be read
				static const Mask Write;						//!< 0x00000002 - Column can be modified
				//@}

				// Combo masks
				static const Mask	Default;					//!< Read | Write
				//@}
			};



			//! The type of columns currently supported
			enum Type
			{
				dbfUndefined,								//!< 0 = type unknown
				dbfMinValid,								//!< 1 = the first valid type (same as dbfString)
				dbfString = dbfMinValid,		//!< 1 = a string
				dbfChar,										//!< 2 = a char
				dbfShort,										//!< 3 = a signed short
				dbfBool,										//!< 4 = a boolean
				dbfInt,											//!< 5 = a signed integer
				dbfLong,										//!< 6 = a signed long
				dbfFloat,										//!< 7 = a float
				dbfDate,										//!< 8 = a date
				dbfBlob,										//!< 9 = a blob
				dbfBinary,									//!< 10 = binary data
				dbfMaxValid = dbfBinary			//!< 10 = the last valid type (same as dbfBinary)
			};

			//! The unit of meassure for a numeric column (has no impact on non-numeric columns)
			enum Unit
			{
				unitGeneric, 								//!<  0 = Default treat as simple number
				unitInch,										//!<  1 = Inch
				unitFoot, 									//!<  2 = Foot
				unitYard,										//!<  3 = Yard
				unitCentimeter,							//!<  4 = Centimeter
				unitMeter,									//!<  5 = Meter
				unitPound,									//!<  6 = Pound
				unitGram,										//!<  7 = Gram
				unitKilogram,								//!<  8 = Kilogram
				unitCelsius,								//!<  9 = Celsius
				unitFarenheit,							//!< 10 = Farenheit
				unitPercent, 								//!< 11 = Percent
				unitMillisecond, 						//!< 12 = Millisecond
				unitSecond, 								//!< 13 = Second
				unitMinute, 								//!< 14 = Minute
				unitHour,		 								//!< 15 = Hour
				unitDay, 										//!< 16 = Day
				unitWeek, 									//!< 17 = Week
				unitMonth, 									//!< 18 = Month
				unitYear	 									//!< 19 = Year
			};

			struct ColumnChoice
			{
				float					SeqNo;
				std::string		Val;
				std::string		Desc;

				ColumnChoice(float fSequenceNo, const std::string & strChoiceVal, const std::string & strChoiceDesc)
					: SeqNo(fSequenceNo),
						Val(strChoiceVal),
						Desc(strChoiceDesc)
				{
				}
			};

			//! ColumnChoice values are stored in a map where the key represents a possible value a column of this type can assume and the value represents a user friendly explanation of how this value is treated
			typedef std::map<float, ColumnChoice>	ColumnChoiceMap;
			typedef ColumnChoiceMap*							ColumnChoiceMapPtr;
			typedef ColumnChoiceMap::iterator			ColumnChoiceMapItr;

		protected:
			static ColumnID						M_uNextInternalID;	//!< If no internal ID is passed to the constructor, use this and decrement afterwards (used for meta dictionary definition meta obejcts)
			static MetaColumnPtrMap		M_mapMetaColumn;		//!< Holds all MetaColumn objects in the system indexed by m_uID

			MetaEntityPtr					m_pMetaEntity;					//!< The meta table of which this is a column
			ColumnID							m_uID;									//!< This is the index of this so that (MetaColumn::M_mapMetaColumn.find(m_uID)->second == this)
			ColumnIndex						m_uColumnIdx;						//!< This is the index of this so that (m_pMetaEntity->GetMetaColumn(m_uColumnIdx) == this)
			std::string						m_strName;							//!< The Columns Name
			std::string						m_strProsaName;					//!< User friendly name
			std::string						m_strDescription;				//!< A description of the entity
			const Class*					m_pInstanceClass;				//!< pointer to class that knows how to construct ako Column object which this returns as response to CreateInstance
			std::string						m_strInstanceInterface;	//!< The name of the interface class that can wrap an instance of this type
			std::string						m_strJSMetaClass;				//!< The name of the JavaScript meta class representing this in the browser
			std::string						m_strJSInstanceClass;		//!< The name of the JavaScript instance class representing this in the browser
			std::string						m_strJSViewClass;				//!< The name of the JavaScript widget that knows how to render instances of this type as a APALUI widget in the browser (full)
			Flags									m_Flags;								//!< See MetaColumn::Flags class
			Permissions						m_Permissions;					//!< See MetaColumn::Permissions class
			bool									m_bNullDefault;					//!< If true, the default value for new instances of this MetaColumn is NULL
			MetaKeyPtrVect				m_vectMetaKey;					//!< The MetaKey objects of which this is a member
			MetaRelationPtrVect		m_vectMetaRelation;			//!< The MetaRelation objects which this switches
			ColumnChoiceMapPtr		m_pMapColumnChoice;			//!< If this is a multi or single choice column, this map stores allowable values where the key represents a possible value a column of this type can assume and the value represents a user friendly explanation of how this value is treated
			bool									m_bPKMember;						//!< true if this is a member of a primary key
			Unit									m_uUnit;								//!< See enum Unit above
			unsigned short				m_uFloatPrecision;			//!< The number of digits after the decimal point to display (only relevant for floating point columns dbfReal)
			std::string						m_strHSTopicsJSON;			//!< JSON string containing an array of help topics associated with this

			//! Default ctor()
			/*! This ctor maybe used to create derived MetaColumn objects which don't belong to a MetaEntity
			*/
			MetaColumn();

			//! You don't normally create instances of this class, instead, create MetaColumnString, MetaColumnInt, etc.. (see further down)
			MetaColumn(	MetaEntityPtr pMetaEntity,
															ColumnID uID,
															const std::string & strName,
															const Flags::Mask & flags,
															const Permissions::Mask & permissions,
															const std::string & strInstanceClassName)
				: m_uID(uID),
					m_pMetaEntity(pMetaEntity),
					m_uColumnIdx(D3_UNDEFINED_ID),
					m_strName(strName),
					m_pInstanceClass(NULL),
					m_Flags(flags),
					m_Permissions(permissions),
					m_bNullDefault(true),
					m_pMapColumnChoice(NULL),
					m_bPKMember(false),
					m_uUnit(unitGeneric),
					m_uFloatPrecision(2)
			{
			}

			// The destructor ensures that the MetaEntity is notified if this' death
			//
			virtual ~MetaColumn();

			//! ctor helper
			void											Init(const std::string & strInstanceClassName, const std::string & strDefaultClassName);

		public:
			//! Creates ako D3Column
			/*! Creates ako D3Column based on this (if pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity to which it is attached)
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL) = 0;

			//! Exceptions of all instances of a MetaColumn will be logged to the default EC
			ExceptionContextPtr				GetExceptionContext()							{ return ExceptionContext::GetDefaultExceptionContext(); };

			//! @name Meta data accessors
			//@{
			//! Return MetaEntity object of which this is a member
			MetaEntityPtr							GetMetaEntity()	const							{ return m_pMetaEntity; };
			//! Return an stl vector containing all MetaKey objects of which this is a member
			MetaKeyPtrVect&						GetMetaKeys()											{ return m_vectMetaKey; };
			//! Return an stl vector containing all MetaRelation objects which are switched through this
			MetaRelationPtrVect&			GetSwitchedMetaRelations()				{ return m_vectMetaRelation; };
			//! Return an stl vector containing all MetaKey objects of which this is a member
			unsigned int							GetMetaKeyIndex(MetaKeyPtr pMK);
			//@}

			//! Returns true if this knows the Metakey passed in
			bool											HasMetaKey(MetaKeyPtr pMK)				{ return GetMetaKeyIndex(pMK) < m_vectMetaKey.size(); }

			//! GetID returns a unique identifier which can be used to retrieve the same object using GetMetaColumnByID(unsigned int)
			ColumnID									GetID() const											{ return m_uID; }
			//! Return the meta relation where GetID() == uID
			static MetaColumnPtr			GetMetaColumnByID(ColumnID uID)
			{
				MetaColumnPtrMapItr	itr = M_mapMetaColumn.find(uID);
				return (itr == M_mapMetaColumn.end() ? NULL : itr->second);
			}

			//! Returns a list of all MetaColumns in the system.
			static MetaColumnPtrMap&	GetMetaColumns()									{ return M_mapMetaColumn; };

			//! Returns the index of this column
			ColumnIndex								GetColumnIdx() const							{ return m_uColumnIdx; }
			//! Returns the columns name
			const std::string &				GetName() const										{ return m_strName; }
			//! Returns the columns user meaningful name
			const std::string	&				GetProsaName() const							{ return m_strProsaName.empty() ? m_strName : m_strProsaName; }
			//! Returns a description for the column
			const std::string &				GetDescription() const						{ return m_strDescription; }
			//! Returns an unambiguous name consisting (database.table.name)
			std::string								GetFullName() const;
			//! Returns the instance class name this uses
			const std::string &				GetInstanceClassName() const			{ return m_pInstanceClass->Name(); }
			//! Returns the name of the interface that is expected to wrap an instance of this type
			const std::string &				GetInstanceInterface()						{ return  m_strInstanceInterface;}
			//! Returns the JavaScript MetaClass to use on the browser side
			const std::string &				GetJSMetaClassName() const				{ return m_strJSMetaClass; }
			//! Returns the JavaScript InstanceClass to use on the browser side
			const std::string &				GetJSInstanceClassName() const		{ return m_strJSInstanceClass; }
			//! Returns the JavaScript ViewClass to use on the browser side
			const std::string &				GetJSViewClassName() const				{ return m_strJSViewClass; }
			//! Returns the Unit type this column uses (only meaning ful if this is a numeric column)
			Unit											GetUnit()													{ return  m_uUnit;}
			//! Returns the UOM in string representation of this' Unit (not for display purposes!!!)
			const char*								UnitToString()										{ return UnitToString(this->m_uUnit); }
			//! Returns the UOM in string representation of a Unit (not for display purposes!!!)
			static const char*				UnitToString(Unit eUnit);
			//! Returns the Unit type this column uses as string
			static Unit								StringToUnit(const std::string& strUOM);
			//! If the meta columns unit is imperial, make it metric
			void											MakeMetric();
			//! If the meta columns unit is metric, make it imperial
			void											MakeImperial();
			//! Returns the Unit type this column uses (only meaning ful if this is a numeric column)
			unsigned short						GetFloatPrecision()								{ return  m_uFloatPrecision;}

			//! Set the index of a column, this interface is here only for use with derived MetaColumn objects
			void											SetColumnIdx(ColumnIndex uColumnIdx){ assert(IsDerived()); m_uColumnIdx = uColumnIdx; }

			//! Allows you to set the default value for new instances of this to NULL
			/*! Subclasses of this will allow you to set specific default values. When using
					any of these methods the default value for new instances is no longer NULL.
					Therefore, after calling one of these methods you can call this method again
					to reset the default value to NULL. After creating a new instance of MetaColumn,
					the default value for new columns is always NULL.
			*/
			void											SetDefaultValueNull()							{ m_bNullDefault = true; }

			//! Allows you to set the default value for new instances of this
			/*! Subclasses of this will implement this method
			*/
			virtual void							SetDefaultValue(const std::string & strDefaultValue) = 0;

			//! Allows you to get the default value (in string representation)
			/*! The return value of this method is only meaningfull if this->IsDefaultValueNull() is false
			*/
			virtual std::string				GetDefaultValue() = 0;

			//! @Type Type details
			/*!  These details must be returned by specific implementations of this class
			*/
			virtual std::string				GetTypeAsCString() = 0;
			virtual std::string				GetTypeAsString() = 0;
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget) = 0;
			virtual std::string				GetTypeAsIceIType() = 0;
			virtual std::string				GetTypeAsIceCType() = 0;
			virtual unsigned int			GetMaxLength() = 0;
			virtual Type							GetType() = 0;
			//@}

			//! @name Flag accessors
			/*! These accessors are used to determine the characteristics of a column
			*/
			//@{
			//! Returns the characteristics bitmask
			const Flags &							GetFlags() const									{ return m_Flags; }

			bool											IsHiddenOnDetailView() const			{ return m_Flags & Flags::HiddenOnDetailView;}//!< Returns true if this should be hidden on entity list views
			bool											IsHiddenOnListView() const				{ return m_Flags & Flags::HiddenOnListView;}//!< Returns true if this should be hidden on entity list views
			bool											IsMandatory() const								{ return m_Flags & Flags::Mandatory; }		//!< Returns true if this column must have a valid value, false otherwise.
			bool											IsAutoNum() const									{ return m_Flags & Flags::AutoNum; }			//!< Returns true if this column is an AutoNum column (value set by RDBMS on INSERT), false otherwise.
			bool											IsDerived() const									{ return m_Flags & Flags::Derived; }			//!< Returns true if this column is not a column of the physical table in the RDBMS, false otherwise.
			bool											IsEncodedValue() const						{ return m_Flags & Flags::EncodedValue;}	//!< Returns true if this's value will be passed to/retrieved from external clients as base64 encoded strings (external clients are those using ICE to communicate with APALSvc). This only applies to String and BLOB columns.

			//! Returns true if this is a single choice column that knows the allowed values
			bool											IsSingleChoice() const						{ return m_pMapColumnChoice && (m_Flags & Flags::SingleChoice) && !(m_Flags & Flags::MultiChoice); }

			//!< Returns true if this is a multiple choice column that knows the allowed values
			bool											IsMultiChoice() const							{ return m_pMapColumnChoice && (m_Flags & Flags::MultiChoice); }

			//!< Returns true if this column is to be lazy fetched. Note: Key columns are never lazy fetchable even if marked as such.
			bool											IsLazyFetch() const               { return (m_Flags & Flags::LazyFetch) && !IsKeyMember(); }

			//!< False at this level, only MetaColumnString can retyurn true
			virtual bool							IsPassword() const								{ return false; }

			bool											IsDefaultValueNull() const				{ return m_bNullDefault; }							//!< Returns true if this has a default value
			bool											IsKeyMember() const								{ return !m_vectMetaKey.empty(); }			//!< Returns true if this column is a member of one or more keys, false otherwise.
			bool											IsPrimaryKeyMember() const				{ return m_bPKMember; };								//!< Returns true if this is a member of the primary MetaKey of the MetaEntity this belongs to
			//@}


			//@{ Permissions
			//! Returns the permissions bitmask
			const Permissions &				GetPermissions() const						{ return m_Permissions; }

			//! Returns true if values of such columns can be seen by users, false otherwise.
			bool											AllowRead() const									{ return m_Permissions & Permissions::Read; }
			//! Returns true if values of such columns can be modified by users, false otherwise.
			bool											AllowWrite() const								{ return m_Permissions & Permissions::Write; }

			//! Sets the Read permission to on or off
			void 											AllowRead(bool bEnable)						{ bEnable ? m_Permissions |= Permissions::Read : m_Permissions &= ~Permissions::Read; }
			//! Sets the Write permission to on or off
			void 											AllowWrite(bool bEnable)					{ bEnable ? m_Permissions |= Permissions::Write : m_Permissions &= ~Permissions::Write; }
			//@}


			//! Returns true if this is a streamed column (this is true for LOB's)
			virtual bool							IsStreamed() const								{ return false; }

			//! Returns a string representing the meaning of a columns value as a string
			/*!	This method can only be called if this is a single choice column. In other
					words, this->IsSingleChoice() == true is a prerequisite!
			*/
			std::string								ChoiceDescAsString(const std::string & strChoiceVal);

			//! Returns a string list representing the currently selected values of a multi choice column
			/*!	This method can only be called if this is a multi choice column. In other
					words, this->IsMultiChoice() == true is a prerequisite!
					A multi choice column has a maximum length of one machine word. The associated
					choices are ordered from LSB to MSB. You can't have more than:
					max(sizeof(columntype)*8, sizeof(long)*8);
					choices. If your choice list contains fewer values than bit's in the passed in value,
					the values of extra bits are ignored.
					This method returns a list of strings representing the currently selected choices.
			*/
			StringList								ChoiceDescs(unsigned long lValue);

			//! Returns a string representing the currently selected values of a multi choice column
			/*!	The returned string contains the currently selected values enclosed in square brackets.
					See also: StringList MetaColumn::ChoiceDescs(unsigned long lValue);
					This method returns a list of strings representing the currently selected choices.
			*/
			std::string								ChoiceDescsAsString(unsigned long lValue);

			//! Returns a list of choices associated with this meta column
			ColumnChoiceMapPtr				GetChoiceMap()										{ return m_pMapColumnChoice; }

			//! Debug aid: The method dumps this and (if bDeep is true) all its objects to cout
			void											Dump(int nIndentSize = 0, bool bDeep = true);

			//! Returns all known and accessible instances of D3::MetaColumn as a JSON stream
			static std::ostream &			AllAsJSON(RoleUserPtr pUserRole, std::ostream & ostrm);

			//! Writes this meta column to the passed-in JSON stream
			std::ostream &						AsJSON(RoleUserPtr pRoleUser, std::ostream & ostrm, bool * pFirstChild = NULL);

			//! Returns the Abbreviation of Unit type this column uses
			std::string								GetAbbreviationofUnit();

			//! Compares two MetaColumn objects.
			/*! Please refer to the actual non-abstract subclasses for details of how this is handled
			*/
			virtual int								Compare(ObjectPtr pObj) = 0;

		protected:
			//! Called by #MetaEntity::LoadMetaObject().
			/*!	The method expects that the Entity object passed in is an instance of the D3MetaColumn
					MetaEntity and constructs a new MetaColumn object based on pD3MC which acts as
					a template.
			*/
			static void								LoadMetaObject(MetaEntityPtr pMetaEntity, D3MetaColumnPtr pD3MC);

			//! Return this as a component which is inside an CREATE TABLE ... sql string
			virtual std::string				AsCreateColumnSQL(TargetRDBMS eTarget);

			//! No need to do anything here at this stage
			void											On_InstanceCreated(ColumnPtr pColumn)	{};
			//! No need to do anything here at this stage
			void											On_InstanceDeleted(ColumnPtr pColumn)	{};

			//! Notification from a MetaKey object that it has added this as one of it's collection of columns
			void											On_AddedToMetaKey(MetaKeyPtr pMetaKey);
			//! Notification from a MetaKey object that it has removed this from it's collection of columns
			void											On_RemovedFromMetaKey(MetaKeyPtr pMetaKey);

			//! Notification from a MetaRelation object using this as it's switch that it has been created
			void											On_MetaRelationCreated(MetaRelationPtr pMetaRelation);
			//! Notification from a MetaRelation object using this as it's switch that it has been deleted
			void											On_MetaRelationDeleted(MetaRelationPtr pMetaRelation);

			//! If possible, sets this' internal m_strDescription to a default value if it is empty.
			/*! Provided the this' m_strDescription is empty and this is a multi or single choice column,
					builds an HTML helpstring that identifies available options. Subsequent calls to
					GetDescription() will return the constructed string.
			*/
			void											SetDefaultDescription();

			//! Sets the JSON HSTopic array
			void											SetHSTopics(const std::string & strHSTopicsJSON) { m_strHSTopicsJSON = strHSTopicsJSON; }
	};




	//! The MetaColumnString class is a specialisation of the MetaColumn class dealing specifically with string column types
	class D3_API MetaColumnString : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnString);

		protected:
			unsigned int					m_iMaxLen;					//!< the maximum length (for varchars)
			std::string						m_strDefaultValue;	//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnString() : m_iMaxLen(0) {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnString(MetaEntityPtr pMetaEntity, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnString");
			//! Normal ctor()
			/*! This constructor will create a MetaColumn object which when asked to CreateInstance() returns
					an object of the C++ class identified by name. Note that the strClassName must be the name of
					a class based directly or indirectly on D3::ColumnString or it can be blank or omited in which case
					it is assumed to be "ColumnString".
			*/
			MetaColumnString(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnString");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "std::string"; }
			virtual std::string				GetTypeAsIceIType()								{ return "string"; }
			virtual std::string				GetTypeAsIceCType()								{ return "std::string"; }
			virtual std::string				GetTypeAsString()									{ return "String"; }
			virtual unsigned int			GetMaxLength()										{ return m_iMaxLen; }
			virtual Type							GetType()													{ return MetaColumn::dbfString; }
			//@}

			//! Returns true if the maximum string length is longer than 4000 (Oracle == LONG and SQLServer == Text datatype which are streamed)
			virtual bool							IsStreamed() const								{ return m_iMaxLen > D3_MAX_CONVENTIONAL_STRING_LENGTH; }

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				m_strDefaultValue = strDefaultValue;
				m_bNullDefault = false;
			}

			//! Sets this' default value
			std::string								GetDefaultValue()
			{
				return m_strDefaultValue;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnString class the method returns -1 and writes
					an error to the log. Otherwise it compares the maximum length of the two
					column types and if pObj is less than this returns -1, if they are the same
					0 and if this is longer 1.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnChar : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnChar);

		protected:
			char									m_cDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnChar() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnChar(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnChar");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnChar or it can be blank or omited in which case
			// it is assumed to be "ColumnChar".
			//
			MetaColumnChar(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnChar");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "char"; }
			virtual std::string				GetTypeAsIceIType()								{ return "byte"; }
			virtual std::string				GetTypeAsIceCType()								{ return "Ice::Byte"; }
			virtual std::string				GetTypeAsString()									{ return "Char"; }
			virtual unsigned int			GetMaxLength()										{ return 4; }
			virtual Type							GetType()													{ return MetaColumn::dbfChar; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				char			cVal;
				Convert(cVal, strDefaultValue);
				SetDefaultValue(cVal);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_cDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(char cDefaultValue)
			{
				m_cDefaultValue = cDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnChar class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnShort : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnShort);

		protected:
			short											m_sDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnShort() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnShort(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnShort");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnShort or it can be blank or omited in which case
			// it is assumed to be "ColumnShort".
			//
			MetaColumnShort(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnShort");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "short"; }
			virtual std::string				GetTypeAsIceIType()								{ return "short"; }
			virtual std::string				GetTypeAsIceCType()								{ return "Ice::Short"; }
			virtual std::string				GetTypeAsString()									{ return "Short"; }
			virtual unsigned int			GetMaxLength()										{ return 6; }
			virtual Type							GetType()													{ return MetaColumn::dbfShort; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				short sDefaultValue;
				Convert(sDefaultValue, strDefaultValue);
				SetDefaultValue(sDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_sDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(short sDefaultValue)
			{
				m_sDefaultValue = sDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnShort class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnBool : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnBool);

		protected:
			bool									m_bDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnBool() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnBool(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBool");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnBool or it can be blank or omited in which case
			// it is assumed to be "ColumnBool".
			//
			MetaColumnBool(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBool");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "bool"; }
			virtual std::string				GetTypeAsIceIType()								{ return "bool"; }
			virtual std::string				GetTypeAsIceCType()								{ return "bool"; }
			virtual std::string				GetTypeAsString()									{ return "Boolean"; }
			virtual unsigned int			GetMaxLength()										{ return 11; }
			virtual Type							GetType()													{ return MetaColumn::dbfBool; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				bool bDefaultValue;
				Convert(bDefaultValue, strDefaultValue);
				SetDefaultValue(bDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_bDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(bool bDefaultValue)
			{
				m_bDefaultValue = bDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnBool class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnInt : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnInt);

		protected:
			int									m_iDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnInt() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnInt(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnInt");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnInt or it can be blank or omited in which case
			// it is assumed to be "ColumnInt".
			//
			MetaColumnInt(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnInt");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "int"; }
			virtual std::string				GetTypeAsIceIType()								{ return "int"; }
			virtual std::string				GetTypeAsIceCType()								{ return "Ice::Int"; }
			virtual std::string				GetTypeAsString()									{ return "Integer"; }
			virtual unsigned int			GetMaxLength()										{ return 11; }
			virtual Type							GetType()													{ return MetaColumn::dbfInt; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				int iDefaultValue;
				Convert(iDefaultValue, strDefaultValue);
				SetDefaultValue(iDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_iDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(int iDefaultValue)
			{
				m_iDefaultValue = iDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnInt class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnLong : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnLong);

		protected:
			long									m_lDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnLong() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnLong(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnLong");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnLong or it can be blank or omited in which case
			// it is assumed to be "ColumnLong".
			//
			MetaColumnLong(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnLong");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "long"; }
			virtual std::string				GetTypeAsIceIType()								{ return "long"; }
			virtual std::string				GetTypeAsIceCType()								{ return "Ice::Long"; }
			virtual std::string				GetTypeAsString()									{ return "Long"; }
			virtual unsigned int			GetMaxLength()										{ return 11; }
			virtual Type							GetType()													{ return MetaColumn::dbfLong; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				long lDefaultValue;
				Convert(lDefaultValue, strDefaultValue);
				SetDefaultValue(lDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_lDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(long lDefaultValue)
			{
				m_lDefaultValue = lDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnLong class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnFloat : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnFloat);

		protected:
			float											m_fDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnFloat() {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnFloat(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnFloat");
			//! Normal ctor()
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnFloat or it can be blank or omited in which case
			// it is assumed to be "ColumnFloat".
			//
			MetaColumnFloat(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnFloat");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "float"; }
			virtual std::string				GetTypeAsIceIType()								{ return "float"; }
			virtual std::string				GetTypeAsIceCType()								{ return "Ice::Float"; }
			virtual std::string				GetTypeAsString()									{ return "Float"; }
			virtual unsigned int			GetMaxLength()										{ return 16; }
			virtual Type							GetType()													{ return MetaColumn::dbfFloat; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				float fDefaultValue;
				Convert(fDefaultValue, strDefaultValue);
				SetDefaultValue(fDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_fDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(float fDefaultValue)
			{
				m_fDefaultValue = fDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnFloat class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	class D3_API MetaColumnDate : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnDate);

		protected:
			D3Date											m_dtDefaultValue;		//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnDate() {}

			//! ctor() used to initialise objects to access meta dictionary database
			//! Normal ctor()
			MetaColumnDate(MetaEntityPtr pMetaEntity, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnDate");
			// This constructor will create a MetaColumn object which when asked to CreateInstance() returns
			// an object of the C++ class identified by name. Note that the strClassName must be the name of
			// a class based directly or indirectly on D3::ColumnDate or it can be blank or omited in which case
			// it is assumed to be "ColumnDate".
			//
			MetaColumnDate(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnDate");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "D3Date"; }
			virtual std::string				GetTypeAsIceIType()								{ return "string"; }
			virtual std::string				GetTypeAsIceCType()								{ return "std::string"; }
			virtual std::string				GetTypeAsString()									{ return "Date"; }
			virtual unsigned int			GetMaxLength()										{ return 26; }
			virtual Type							GetType()													{ return MetaColumn::dbfDate; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				D3Date dtDefaultValue;
				Convert(dtDefaultValue, strDefaultValue);
				SetDefaultValue(dtDefaultValue);
			}

			//! Get this' default value as a string representation
			std::string								GetDefaultValue()
			{
				std::string		strVal;
				Convert(strVal, m_dtDefaultValue);
				return strVal;
			}

			//! Sets this' default value
			void											SetDefaultValue(const D3Date & dtDefaultValue)
			{
				m_dtDefaultValue = dtDefaultValue;
				m_bNullDefault = false;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnDate class the method returns -1 and writes
					an error to the log. Otherwise it returns 0.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	//! The MetaColumnBlob class is a specialisation of the MetaColumn class dealing specifically with Large Binary (BLOB) column types
	class D3_API MetaColumnBlob : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnBlob);

		protected:
			unsigned int			    m_iMaxLen;					//!< the maximum length (for varchars)
			std::string						m_strDefaultValue;	//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnBlob() : m_iMaxLen(0) {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnBlob(MetaEntityPtr pMetaEntity, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBlob");
			//! Normal ctor()
			/*! This constructor will create a MetaColumn object which when asked to CreateInstance() returns
					an object of the C++ class identified by name. Note that the strClassName must be the name of
					a class based directly or indirectly on D3::ColumnBlob or it can be blank or omited in which case
					it is assumed to be "ColumnBlob".
			*/
			MetaColumnBlob(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBlob");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "std::stringstream"; }
			virtual std::string				GetTypeAsIceIType()								{ return "std::string"; }
			virtual std::string				GetTypeAsIceCType()								{ return "std::string"; }
			virtual std::string				GetTypeAsString()									{ return "Blob"; }
			virtual unsigned int			GetMaxLength()										{ return m_iMaxLen; }
			virtual Type							GetType()													{ return MetaColumn::dbfBlob; }
			//@}

			//! Returns true because the value of BLOB columns is always retrieved from streams
			virtual bool							IsStreamed() const								{ return true; }

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				m_strDefaultValue = strDefaultValue;
				m_bNullDefault = false;
			}

			//! Sets this' default value
			std::string								GetDefaultValue()
			{
				return m_strDefaultValue;
			}

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnBlob class the method returns -1 and writes
					an error to the log. Otherwise it compares the maximum length of the two
					column types and if pObj is less than this returns -1, if they are the same
					0 and if this is longer 1.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	//! The MetaColumnBinary class is a specialisation of the MetaColumn class dealing specifically with Binary column types
	class D3_API MetaColumnBinary : public MetaColumn
	{
		friend class MetaColumn;
		friend class MetaDatabase;
		friend class MetaEntity;
		friend class MetaKey;
		friend class MetaRelation;
		friend class Entity;
		friend class Column;

		D3_CLASS_DECL(MetaColumnBinary);

		protected:
			unsigned int			    m_iMaxLen;					//!< the maximum length (for varchars)
			std::string						m_strDefaultValue;	//!< If not empty, new values will be initialised automatically with this value

			//! Default ctor()
			/*! This ctor may be called by the D3 class factory system
			*/
			MetaColumnBinary() : m_iMaxLen(0) {}

			//! ctor() used to initialise objects to access meta dictionary database
			MetaColumnBinary(MetaEntityPtr pMetaEntity, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBinary");
			//! Normal ctor()
			/*! This constructor will create a MetaColumn object which when asked to CreateInstance() returns
					an object of the C++ class identified by name. Note that the strClassName must be the name of
					a class based directly or indirectly on D3::ColumnBinary or it can be blank or omited in which case
					it is assumed to be "ColumnBinary".
			*/
			MetaColumnBinary(MetaEntityPtr pMetaEntity, ColumnID uID, const std::string & strName, unsigned int iMaxLength, const Flags::Mask & flags = Flags::Default, const Permissions::Mask & permissions = Permissions::Default, const std::string & strClassName = "ColumnBinary");

		public:
			//! Create a matching instances
			/*! If pEntity is NULL, the instance is detached and must be deleted
					seperately, otherwise the returned instance will die with the pEntity.
			*/
			virtual ColumnPtr					CreateInstance(EntityPtr pEntity = NULL);

			//! @Type Type details
			/*! Returns type details specific to string columns
			*/
			virtual std::string				GetTypeAsSQLString(TargetRDBMS eTarget);
			virtual std::string				GetTypeAsCString()								{ return "std::stringstream"; }
			virtual std::string				GetTypeAsIceIType()								{ return "std::string"; }
			virtual std::string				GetTypeAsIceCType()								{ return "std::string"; }
			virtual std::string				GetTypeAsString()									{ return "Binary"; }
			virtual unsigned int			GetMaxLength()										{ return m_iMaxLen; }
			virtual Type							GetType()													{ return MetaColumn::dbfBinary; }
			//@}

			//! Sets this' default value
			void											SetDefaultValue(const std::string & strDefaultValue)
			{
				m_strDefaultValue = strDefaultValue;
				m_bNullDefault = false;
			}

			//! Sets this' default value
			std::string								GetDefaultValue()
			{
				return m_strDefaultValue;
			}

			//!< Returns true if this is a password column
			virtual bool							IsPassword() const								{ return (m_Flags & MetaColumn::Flags::Password); }

			//! Compares two Meta Columns.
			/*! If pObj is not ako MetaColumnBinary class the method returns -1 and writes
					an error to the log. Otherwise it compares the maximum length of the two
					column types and if pObj is less than this returns -1, if they are the same
					0 and if this is longer 1.
			*/
			virtual int								Compare(ObjectPtr pObj);
	};





	//! Column is an abstract base class that defines methods available to all types of columns
	/*! You can think of a column as an object that has a value (which can be NULL) and that
			points to ako MetaColumn object which describes it in detail.
			Though not always true, a column object typically belongs to a particular entity.
	*/
	class D3_API Column : public Object
	{
		friend class MetaColumn;
		friend class MetaColumnString;
		friend class MetaColumnChar;
		friend class MetaColumnShort;
		friend class MetaColumnBool;
		friend class MetaColumnInt;
		friend class MetaColumnLong;
		friend class MetaColumnFloat;
		friend class MetaColumnDate;
		friend class MetaColumnBlob;
		friend class MetaColumnBinary;
		friend class InstanceKey;

		D3_CLASS_DECL_PV(Column);

		protected:
			#define D3_COLUMN_DIRTY			0x01
			#define D3_COLUMN_NULL			0x02
			#define D3_COLUMN_FETCHED		0x04
			#define D3_COLUMN_UNDEFINED	0x08

			// References to these will be returned if values are accessed which are NULL
			//
			static std::string					M_strNull;
			static char									M_cNull;
			static short								M_sNull;
			static bool									M_bNull;
			static int									M_iNull;
			static long									M_lNull;
			static float								M_fNull;
			static D3Date								M_dtNull;
			static std::stringstream 		M_blobNull;
			static Data									M_dataNull;

			MetaColumnPtr								m_pMetaColumn;			// The meta column
			unsigned short							m_uFlags;						// see #defines above
			EntityPtr										m_pEntity;					// The entity of which this is a member
			KeyPtrVectPtr								m_pVectKey;					//!< If this is a key column, this vector contains the keys of which this is a member

			Column()
				: m_pMetaColumn(NULL),
					m_pEntity(NULL),
					m_uFlags(D3_COLUMN_NULL),
					m_pVectKey(NULL)
			{
			}

			Column(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: m_pMetaColumn(pMetaColumn),
					m_pEntity(pEntity),
					m_uFlags(D3_COLUMN_NULL),
					m_pVectKey(NULL)
			{
				assert(m_pMetaColumn);
			}

			Column(Column & aCol)
				: Object(aCol),
          m_pMetaColumn(aCol.m_pMetaColumn),
					m_uFlags(D3_COLUMN_NULL),
					m_pEntity(NULL),
					m_pVectKey(NULL)
			{
			}

		public:
			virtual ~Column();

			//! Meta data access
			MetaColumnPtr						GetMetaColumn()	const															{ return m_pMetaColumn; };

			//! Exception context from entity or default
			ExceptionContextPtr			GetExceptionContext()	const												{ return m_pEntity ? m_pEntity->GetExceptionContext() : ExceptionContext::GetDefaultExceptionContext(); }

			//! Return the entity which owns this
			EntityPtr								GetEntity()																				{ return m_pEntity; }

			//! Create a copy of a column.
			/*! NOTE: The new instance returned is not attached to an Entity
			*/
			virtual Column *				CreateCopy() = 0;

			//! Returns true if this does not vary by more than fVariation. fVariation is
			/*! A positive pecentage figure in the range [0.0...100.0].
					NOTE: - The method returns false if aCol is a different type than this.
					      - If both this and aCol are NULL, the method returns true
					      - If this is NULL and aCol is not (or vice versa) the method returns false
					      - If the type is not numeric, it returns the result of this->operator==(aCol)
			*/
			virtual bool						IsApproximatelyEqual(Column & aCol, float fVariation) = 0;

			//! Returns a date that is internally regarded as a NULL date.
			/*! \note If you assign this date to a date column, the column is considered null.
					Similarly, if a date column is NULL and you access its D3Date object, the
					returned date will be equal to the date this static method returns.
			*/
			static const D3Date&		GetNullDate()			{ return M_dtNull; }

			/** @name Binary operators
			*/
			//@{
			virtual bool						operator==(Column & aCol)													{ return Compare(&aCol) == 0; }
			virtual bool						operator!=(Column & aCol)													{ return Compare(&aCol) != 0; }
			virtual bool						operator> (Column & aCol)													{ return Compare(&aCol) >  0; }
			virtual bool						operator< (Column & aCol)													{ return Compare(&aCol) <  0; }
			virtual bool						operator>=(Column & aCol)													{ return Compare(&aCol) >= 0; }
			virtual bool						operator<=(Column & aCol)													{ return Compare(&aCol) <= 0; }
			//@}

			/** @name Assignment translators
			*/
			//@{
			virtual	Column&					operator=(const char * psz)												{ assert(false); return *this; }
			virtual	Column&					operator=(const std::string & strVal)							{ assert(false); return *this; }
			virtual	Column&					operator=(const char & cVal)											{ assert(false); return *this; }
			virtual	Column&					operator=(const short & sVal)											{ assert(false); return *this; }
			virtual	Column&					operator=(const bool & bVal)											{ assert(false); return *this; }
			virtual	Column&					operator=(const int & iVal)												{ assert(false); return *this; }
			virtual	Column&					operator=(const long & lVal)											{ assert(false); return *this; }
			virtual	Column&					operator=(const float & fVal)											{ assert(false); return *this; }
			virtual	Column&					operator=(const D3Date & tmVal)										{ assert(false); return *this; }
			virtual	Column&					operator=(std::istringstream & stringstream)			{ assert(false); return *this; }
			//@}

			virtual	bool						Assign(Column & aCol) = 0;

			// typecast operators
			//
			virtual									operator const std::string & () const							{ assert(false); return M_strNull; }
			virtual									operator const char & () const										{ assert(false); return M_cNull; }
			virtual									operator const short & () const										{ assert(false); return M_sNull; }
			virtual									operator const bool & () const										{ assert(false); return M_bNull; }
			virtual									operator const int & () const											{ assert(false); return M_iNull; }
			virtual									operator const long & () const										{ assert(false); return M_lNull; }
			virtual									operator const float & () const										{ assert(false); return M_fNull; }
			virtual									operator const D3Date & () const									{ assert(false); return M_dtNull; }
			virtual									operator const std::stringstream  & () const			{ assert(false); return M_blobNull; }
			virtual									operator const Data & () const										{ assert(false); return M_dataNull; }

			// Set the column's value
			//
			virtual bool						SetNull();

			virtual bool						SetValue(const Json::Value & jsonValue);

			virtual bool						SetValue(const char * psz)												{ return SetValue(std::string(psz)); }
			virtual bool						SetValue(const std::string & strVal)							{ assert(false); return false; }
			virtual bool						SetValue(const char & cVal)												{ assert(false); return false; }
			virtual bool						SetValue(const short & sVal)											{ assert(false); return false; }
			virtual bool						SetValue(const bool & bVal)												{ assert(false); return false; }
			virtual bool						SetValue(const int & iVal)												{ assert(false); return false; }
			virtual bool						SetValue(const long & lVal)												{ assert(false); return false; }
			virtual bool						SetValue(const float & fVal)											{ assert(false); return false; }
			virtual bool						SetValue(const D3Date & tmVal)										{ assert(false); return false; }
			virtual bool						SetValue(std::stringstream & stringstream)				{ assert(false); return false; }
			virtual bool						SetValue(const Data& bVal)												{ assert(false); return false; }
			virtual bool						SetValue(const unsigned char* p, unsigned int l)	{ assert(false); return false; }

			//! Special method which converts dNewValue from strInUOM to the meta columns unit value and assigns the value to this
			virtual bool						SetValue(const double dNewValue, const std::string& strInUOM);

			const std::string &			GetString() const																	{ return this->operator const std::string & (); };
			const char &						GetChar() const																		{ return this->operator const char & (); };
			const short &						GetShort() const																	{ return this->operator const short & (); };
			const bool &						GetBool() const																		{ return this->operator const bool & (); };
			const int &							GetInt() const																		{ return this->operator const int & (); };
			const long &						GetLong() const																		{ return this->operator const long & (); };
			const float &						GetFloat() const																	{ return this->operator const float & (); };
			const D3Date &					GetDate() const																		{ return this->operator const D3Date & (); };
			const std::stringstream& GetBlob() const                                  { return this->operator const std::stringstream & (); };
			const Data &						GetData() const																		{ return this->operator const Data & (); };

			virtual std::string			AsString(bool bHumanReadable = true)							{ assert(false); return M_strNull; }
			virtual char						AsChar()																					{ assert(false); return M_cNull; }
			virtual short						AsShort()																					{ assert(false); return M_sNull; }
			virtual bool						AsBool()																					{ assert(false); return M_bNull; }
			virtual int							AsInt()																						{ assert(false); return M_iNull; }
			virtual long						AsLong()																					{ assert(false); return M_lNull; }
			virtual float						AsFloat()																					{ assert(false); return M_fNull; }
			virtual D3Date					AsDate()																					{ assert(false); return M_dtNull; }
			virtual Data						AsData()																					{ assert(false); return M_dataNull; }

			virtual std::string			AsSQLString()= 0;

			// returns true if the TypedColumn matches it's requirements
			//
			virtual bool						Verify() const																		{ return true; };

			bool										IsUndefined() const																{ return (m_uFlags & D3_COLUMN_UNDEFINED) ? true : false; };
			bool										IsNull() const																		{ return (m_uFlags & D3_COLUMN_NULL) ? true : false; };
			bool										IsDirty() const																		{ return (m_uFlags & D3_COLUMN_DIRTY) ? true : false; };
			bool										IsFetched() const																	{ return (m_uFlags & D3_COLUMN_FETCHED) ? true : false; };

			void										MarkUndefined()																		{ m_uFlags |= D3_COLUMN_UNDEFINED; };
			void										MarkDefined()																			{ m_uFlags &= ~D3_COLUMN_UNDEFINED; };

			void										MarkClean()																				{ m_uFlags &= ~D3_COLUMN_DIRTY; }
			void										MarkDirty()																				{ m_uFlags |= D3_COLUMN_DIRTY; };

			void										MarkUnfetched()																		{ m_uFlags &= ~D3_COLUMN_FETCHED; MarkNotNull(); }
			void										MarkFetched()																			{ m_uFlags |= D3_COLUMN_FETCHED; }

			void										MarkNull()																				{ if (!IsNull()) m_uFlags |=  (D3_COLUMN_NULL | D3_COLUMN_DIRTY);  };
			void										MarkNotNull()																			{ if (IsNull())  m_uFlags &= ~(D3_COLUMN_NULL | D3_COLUMN_DIRTY);  };

			//! Debug helper
			virtual void						Dump (int nIndentSize = 0, int iLabelWidth = 0);

			//! Writes the complete contents of this as JSON to the out stream
			virtual std::ostream &	AsJSON(RoleUserPtr pRoleUser, std::ostream & ostrm, bool* pFirstChild = NULL);

			//! Returns the value of this in JSON format
			virtual std::string			AsJSON(RoleUserPtr pRoleUser) = 0;

			//! Returns true if this column is a member of at least one key
			virtual bool						IsKeyMember()												{ return m_pMetaColumn->IsKeyMember(); }

			//! Returns true if this column is a member of the key this->m_pMetaEntity->GetPrimaryKey()
			virtual bool						IsPrimaryKeyMember()								{ return m_pMetaColumn->IsPrimaryKeyMember(); }

			//! Allows you to stream the value of a column to an std::ostream
			virtual std::ostream &	ToStream(std::ostream & strmOut)
			{
				strmOut << AsString(true);
				return strmOut;
			}

			//! This method actually retrieves the value of a LazyFetch column from the database.
			/*! The method is only relevant for lazy-fetch columns. For a column to qualify as a
					lazy-fetch column, the following prerequisite must be met:

					\code
					(aColumn.GetMetaColumn()->IsLazyFetch() &&
					!aColumn.GetMetaColumn()->IsKeyColumn() &&
					 aColumn.GetMetaColumn()->IsStreamed()
					\endcode

					The IsStreamed method will automatically return true for columns meeting these
					requirements:

					\code
					(aColumn.GetMetaColumn()->GetType() == MetaColumn::dbfString &&
					 aColumn.GetMetaColumn()->GetMaxLength() > D3_MAX_CONVENTIONAL_STRING_LENGTH) ||
					 aColumn.GetMetaColumn()->GetType() == MetaColumn::dbfBlob
					\endcode

					Although the value itself is not retrieved for lazy-fetch columns during normal
					LoadObject calls, a NULL indicator is retrieved. This means that if aColumn.IsNull()
					returns true, it is considered fetched and aColumn->IsFetched() returns true.

					If both aColumn.IsNull() and aColumn.IsFetched() return false, the column has a value
					that is not currently known. In these cases, this method retrieves the value of this
					column from the database.

					Repeated calls do nothing so it is cheap to call this method every time you need
					the value of a lazy-fetch column.

					\note If you retrieve the value of a lazy-fetch column where aColumn.IsFetched() == false,
					the value returned is incorrect.
			*/
			virtual void						Fetch();

			virtual int							Compare(ObjectPtr pObj) = 0;

			virtual int							Compare(const std::string & val)									{ assert(false); return -1; }
			virtual int							Compare(const char & val)													{ assert(false); return -1; }
			virtual int							Compare(const short & val)												{ assert(false); return -1; }
			virtual int							Compare(const bool & val)													{ assert(false); return -1; }
			virtual int							Compare(const int & val)													{ assert(false); return -1; }
			virtual int							Compare(const long & val)													{ assert(false); return -1; }
			virtual int							Compare(const float & val)												{ assert(false); return -1; }
			virtual int							Compare(const D3Date & val)												{ assert(false); return -1; }
			virtual int							Compare(const Data & val)													{ assert(false); return -1; }

		protected:
			// Return reasonable NULL values when a value is requested from a NULL column
			//
			const	std::string &			NullValue(const std::string & )										{ return M_strNull; }
			const	char &						NullValue(const char & )													{ return M_cNull; }
			const	short &						NullValue(const short & )													{ return M_sNull; }
			const	bool &						NullValue(const bool & )													{ return M_bNull; }
			const	int &							NullValue(const int & )														{ return M_iNull; }
			const	long &						NullValue(const long & )													{ return M_lNull; }
			const	float &						NullValue(const float & )													{ return M_fNull; }
			const	D3Date &					NullValue(const D3Date & )												{ return M_dtNull; }
			const std::stringstream& NullValue(const std::stringstream & )						{ return M_blobNull; }
			const Data&							NullValue(const Data & )													{ return M_dataNull; }

			// Only use the following method if this->IsKeyMember() == true
			virtual bool						HasKey(KeyPtr pKey);

			// Notification sent by an instance key that has added this to it's collection of columns
			virtual void						On_AddedToKey(KeyPtr pKey);
			// Notification sent by an instance key that has removed this from it's collection of columns
			virtual void						On_RemovedFromKey(KeyPtr pKey);

			//! This notification is sent by the associated MetaColumn's CreateInstance() method.
			virtual void						On_PostCreate();

			//@{
			//! Notify others interested in changes to this
			/*! Notify the associated entity that this is about to change or has changed.
					The notification is sent only if this has an entity (TemporaryKey objects
					for example have no associated entity) and the entity is not marked
					populating.
			*/
			virtual bool						NotifyBeforeUpdate();
			virtual bool						NotifyAfterUpdate();
			//@}

	};





	//! Stream a Column to an std::ostream
	/*! Note that this method is not suitable to archive column data.
			The method simply outputs the value in string form.
	*/
	D3_API inline std::ostream & operator << (std::ostream & strmOut, ColumnPtr pColumn)
	{
		return pColumn->ToStream(strmOut);
	}






	//! The ColumnString class defines objects which are instances of MetaColumnString objects
	class D3_API ColumnString : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnString);

		protected:
			std::string								m_strValue;

			ColumnString()
			{
			}

			ColumnString(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnString(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const std::string &() const;

			virtual Column *					CreateCopy()														{ return new ColumnString((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const std::string & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);

	};






	//! The ColumnChar class defines objects which are instances of MetaColumnChar objects
	class D3_API ColumnChar : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnChar);

		protected:
			char											m_cValue;

			ColumnChar()
			{
			}

			ColumnChar(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnChar(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const char &() const;

			virtual Column *					CreateCopy()														{ return new ColumnChar((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const char & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnShort : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnShort);

		protected:
			short											m_sValue;

			ColumnShort()
			{
			}

			ColumnShort(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnShort(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const short &() const;

			virtual Column *					CreateCopy()														{ return new ColumnShort((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const short & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnBool : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnBool);

		protected:
			bool											m_bValue;

			ColumnBool()
			{
			}

			ColumnBool(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnBool(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const bool &() const;

			virtual Column *					CreateCopy()														{ return new ColumnBool((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const bool & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnInt : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnInt);

		protected:
			int											m_iValue;

			ColumnInt()
			{
			}

			ColumnInt(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnInt(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const int &() const;

			virtual Column *					CreateCopy()														{ return new ColumnInt((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const int & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnLong : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnLong);

		protected:
			long											m_lValue;

			ColumnLong()
			{
			}

			ColumnLong(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnLong(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const long &() const;

			virtual Column *					CreateCopy()														{ return new ColumnLong((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const long & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnFloat : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnFloat);

		protected:
			float											m_fValue;

			ColumnFloat()
			{
			}

			ColumnFloat(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity)
			{
			}

			ColumnFloat(Column & aCol)
				: Column(aCol)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const float &() const;

			virtual Column *					CreateCopy()														{ return new ColumnFloat((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const float & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);
	};






	class D3_API ColumnDate : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;

		D3_CLASS_DECL(ColumnDate);

		protected:
			D3Date										m_dtValue;

			ColumnDate()
				: m_dtValue(Column::M_dtNull)
			{
			}

			ColumnDate(MetaColumnPtr pMetaColumn, EntityPtr pEntity)
				: Column(pMetaColumn, pEntity), m_dtValue(Column::M_dtNull)
			{
			}

			ColumnDate(Column & aCol)
				: Column(aCol), m_dtValue(Column::M_dtNull)
			{
				Assign(aCol);
			}

		public:
			virtual std::string 			AsSQLString();
			virtual	std::string 			AsString(bool bHumanReadable = true);
			virtual	char 							AsChar();
			virtual	bool 							AsBool();
			virtual	short 						AsShort();
			virtual	int 							AsInt();
			virtual	long 							AsLong();
			virtual	float 						AsFloat();
			virtual	D3Date 						AsDate();

			virtual	bool 							SetValue(const std::string & strVal);
			virtual	bool 							SetValue(const char & valIn);
			virtual	bool 							SetValue(const short & valIn);
			virtual	bool 							SetValue(const bool & valIn);
			virtual	bool 							SetValue(const int & valIn);
			virtual	bool 							SetValue(const long & valIn);
			virtual	bool 							SetValue(const float & valIn);
			virtual	bool 							SetValue(const D3Date & valIn);

			virtual										operator const D3Date &() const;

			virtual Column *					CreateCopy()														{ return new ColumnDate((Column &) *this); }

			virtual	bool 							Assign(Column & aFld);

			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation);

			virtual	int 							Compare(ObjectPtr pObj);
			virtual	int 							Compare(const D3Date & val);

			virtual std::string				AsJSON(RoleUserPtr pRoleUser);

			//! Overloaded to ensure we also set the internal data to Column::M_dtNull
			virtual bool							SetNull();
	};




	//! The Blob class implements a special Column type for BLOB type columns
	/*! BLOB columns are expected to contain binray data and hence, values between objects of
			this class and the outside world will always be exchanged as Base64 encoded strings.
	*/
	class D3_API ColumnBlob : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;
		friend class ODBCDatabase;
		friend class OTLDatabase;

		D3_CLASS_DECL(ColumnBlob);

		protected:
			std::stringstream						m_Stream;		//!< I/O Stream (should really be marked ios::binary but I had too many problems with it)

			//! Default ctor might be used by D3 only
			ColumnBlob();

			//! This ctor is the most typical way instances of this class are constructed
			ColumnBlob(MetaColumnPtr pMetaColumn, EntityPtr pEntity);

			//! Copy ctor ensures that the new column is identical to this
			ColumnBlob(Column & aCol);

		public:
			//! Compares this with another column, see also Object::Compare (the other column must also be a ColumnBob)
			virtual int								Compare(ObjectPtr	pAnotherBlob);

			//! Creates a new blob column with identical content as this
			virtual Column *					CreateCopy()														{	return new ColumnBlob((Column&) *this); }

			//! Always false
			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation)		{ return Compare(&aCol) == 0; }

			//! Assigns thhe content of this to another column (the other column must also be a ColumnBob)
			virtual	bool 							Assign(Column & aFld);

			//! Such columns must be stored in the database using the binary stream data
			virtual std::string 			AsSQLString()														{ assert(false); return ""; }

			//! Returns this' value JSON encoded
			/*! If IsNull() is true, the string will be "null". Otherwise, the returned string is
					the same as AsBase64String() but enclosed in single quotes.
			*/
			virtual std::string				AsJSON(RoleUserPtr pRoleUser);

			//! Always returns this. data as Base64 encoded string (if this is NULL, the string is empty)
			virtual	std::string 			AsString(bool bHumanReadable = true)		{ return AsBase64String(); }

			//! Assigns the value passed in to this
			/*! The value that is passed in is expected to be Base64 encoded.
					The method decodes the data and writes it to it's internal stream.
					If the input string is empty, it will set this to NULL and release
					the content of the stream.

					If you have binary data to write, use method WriteRaw() instead.
			*/
			virtual	bool 							SetValue(const std::string & strVal);

			//! Extracts the entire content from the stream and assigns it to this
			/*! If the passed in stream is empty, this is set to NULL,
					otherwise, the data contained in stringstream will replace
					the current content in this' stream column
			*/
			virtual	bool 							SetValue(std::stringstream & stream)		{ FromStream(stream); return true; }

			//! Replaces the content of the internal stream with the data passed in
			/*! If nRaw is 0, the internal stream will be cleared and will set this to NULL.
					This method does not check for null terminators. It will write exactly
					nRaw bytes to the internal stream.
			*/
			void											WriteRaw(const char* pszRaw, unsigned int nRaw);

			//! This method returns a heap allocated buffer that contains this' raw data
			/*! You must free the returned buffer using:

					\code
					unsigned int		nSize;
					char*						pBuffer = aBlob.ReadRaw(nSize);
					// work with pBuffer
					delete [] pBuffer;
					\endcode

					Upon return, nSize will be set to the actual size of the BLOB data stored
					in the returned buffer.
			*/
			unsigned char*						ReadRaw(unsigned int& nSize);

			//! Returns the this' data as a Base64 encoded string
			std::string								AsBase64String();

			//! Assigns the content of this to another column (the other column must also be a ColumnBob)
			virtual	Column&						operator=(std::stringstream & stream);

			//! Allow typecasting to const std::stringstream&
			virtual										operator const std::stringstream  & () const			{ return m_Stream; }

			//! Allows you to stream the value of a column to an std::ostream
			virtual std::ostream &		ToStream(std::ostream & strmOut);

			//! Allows you to assign the value from an std::istream
			virtual std::istream &		FromStream(std::istream & strmIn);

		private:
#ifdef APAL_SUPPORT_OTL
			//! Writes' this content to an OTLStream
			void											WriteOTLStream(otl_nocommit_stream & otl_stream);
#endif

			//! Erase the content of the stream
			void											Clear();

	};




	//! The Binary class implements a special Column type for columns that hold binary data
	/*! BLOB columns are expected to contain binray data and hence, values between objects of
			this class and the outside world will always be exchanged as Base64 encoded strings.
	*/
	class D3_API ColumnBinary : public Column
	{
		friend class MetaColumn;
		friend class InstanceKey;
		friend class ODBCDatabase;
		friend class OTLDatabase;

		D3_CLASS_DECL(ColumnBinary);

		protected:
			Data											m_data;		//!< the raw data for this (will be allocated at startup with a buffer big enough to hold m_pMetaColumn->GetMaxLength() bytes)

			//! Default ctor might be used by D3 only
			ColumnBinary() {}

			//! This ctor is the most typical way instances of this class are constructed
			ColumnBinary(MetaColumnPtr pMetaColumn, EntityPtr pEntity) : Column(pMetaColumn, pEntity) {}

			//! Copy ctor ensures that the new column is identical to this
			ColumnBinary(Column & aCol);

		public:
			//! Compares this with another column, see also Object::Compare (the other column must also be a ColumnBob)
			virtual int								Compare(ObjectPtr	pAnotherBinary);

			//! Creates a new binary column with identical content as this
			virtual Column *					CreateCopy()														{	return new ColumnBinary((Column&) *this); }

			//! Always false
			virtual	bool 							IsApproximatelyEqual(Column & aCol, float fVariation)		{ return Compare(&aCol) == 0; }

			//! Assigns thhe content of this to another column (the other column must also be a ColumnBob)
			virtual	bool 							Assign(Column & aFld);

			//! Returns a string that can be used in SQL queries to compare or assign binary data
			/*!	Return value depends on target RDBMS (assuming this has 3 byte hex data 2b95d1)

						Oracle:			hextoraw('2b95d1')
						SqlServer:	0x2b95d1
			*/
			virtual std::string 			AsSQLString();

			//! Returns this' value JSON encoded
			/*! If IsNull() is true, the string will be "null". Otherwise, the returned string is
					the same as AsBase64String() but enclosed in single quotes.
			*/
			virtual std::string				AsJSON(RoleUserPtr pRoleUser);

			//! Always returns this data as Base64 encoded string (if this is NULL, the string is empty)
			virtual	std::string 			AsString(bool bHumanReadable = true)					{ return AsBase64String(); }

			//! Assigns the data passed in to this (copies the smaller of this->GetmetaColumn()->GetMaxLength() and data.length() bytes)
			virtual bool							SetValue(const Data& data);

			//! Assigns the data passed in to this (copies the smaller of this->GetmetaColumn()->GetMaxLength() and l bytes)
			virtual	bool 							SetValue(const unsigned char* p, unsigned int l){ return SetValue(Data(p, std::min(l, m_pMetaColumn->GetMaxLength()))); }

			//! Returns the data
			virtual										operator const Data & () const								{ return m_data; }

			//! Returns the this' data as a Base64 encoded string
			std::string								AsBase64String();

			//! Assigns Data to this
			const Column&							operator=(const Data& data)										{ SetValue(data); return *this; }
	};


} // end namespace D3

#endif /* INC_D3_COLUMN_H_ */
