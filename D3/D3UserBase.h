#ifndef INC_D3UserBase_H
#define INC_D3UserBase_H

// WARNING: This file has been generated by D3. You should NEVER change this file.
//          Please refer to the documentation of MetaEntity::CreateSpecialisedCPPHeader()
//          which explains in detail how you can gegenerate this file.
//
// The file declares methods which simplify client interactions with objects of type 
// D3User representing instances of D3MDDB.D3User.
//
//       For D3 to work correctly, you must implement your own class as follows:
//
//       #include "D3UserBase.h"
//
//       namespace D3
//       {
//         class D3User : public D3UserBase
//         {
//           D3_CLASS_DECL(D3User);
//
//           protected:
//             D3User() {}
//
//           public:
//             ~D3User() {}
//
//             // Insert your specialised member functions here...
//
//         };
//       } // end namespace D3
//

#include "Entity.h"
#include "Column.h"
#include "Key.h"
#include "Relation.h"
#include "D3MDDB.h"

namespace D3
{

	//! Use these enums to access columns through D3User::Column() method
	enum D3User_Fields
	{
		D3User_ID,
		D3User_Name,
		D3User_Password,
		D3User_Enabled,
		D3User_WarehouseAreaAccessList,
		D3User_CustomerAccessList,
		D3User_TransmodeAccessList,
		D3User_PWDAttempts,
		D3User_PWDExpires,
		D3User_Temporary,
		D3User_Language
	};


	//! D3UserBase is a base class that \b MUST be subclassed through a class called \a D3User.
	/*! The purpose of this class to provide more natural access to related objects as well as this' columns.
			This class is only usefull if it is subclassed by a class called D3User
			Equally important is that the meta dictionary knows of the existence of your subclass as well as
			specialised Relation classes implemented herein. Only once these details have been added to the
			dictionary will D3 instantiate objects of type \a D3User representing rows from the table \a D3MDDB.D3User.
	*/
	class D3_API D3UserBase: public Entity
	{
		D3_CLASS_DECL(D3UserBase);

		public:
			//! Enable iterating over all instances of this
			class D3_API iterator : public InstanceKeyPtrSetItr
			{
				public:
					iterator() {}
					iterator(const InstanceKeyPtrSetItr& itr) : InstanceKeyPtrSetItr(itr) {}

					//! De-reference operator*()
					virtual D3UserPtr               operator*();
					//! Assignment operator=()
					virtual iterator&               operator=(const iterator& itr);
			};

			static unsigned int                 size(DatabasePtr pDB)         { return GetAll(pDB)->size(); }
			static bool                         empty(DatabasePtr pDB)        { return GetAll(pDB)->empty(); }
			static iterator                     begin(DatabasePtr pDB)        { return iterator(GetAll(pDB)->begin()); }
			static iterator                     end(DatabasePtr pDB)          { return iterator(GetAll(pDB)->end()); }

			//! Enable iterating the relation D3RoleUsers to access related D3RoleUser objects
			class D3_API D3RoleUsers : public Relation
			{
				D3_CLASS_DECL(D3RoleUsers);

				protected:
					D3RoleUsers() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual D3RoleUserPtr       operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual D3RoleUserPtr           front();
					//! back() method
					virtual D3RoleUserPtr           back();
			};

			//! Enable iterating the relation D3RowLevelPermissions to access related D3RowLevelPermission objects
			class D3_API D3RowLevelPermissions : public Relation
			{
				D3_CLASS_DECL(D3RowLevelPermissions);

				protected:
					D3RowLevelPermissions() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual D3RowLevelPermissionPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual D3RowLevelPermissionPtr front();
					//! back() method
					virtual D3RowLevelPermissionPtr back();
			};

			//! Enable iterating the relation D3HistoricPasswords to access related D3HistoricPassword objects
			class D3_API D3HistoricPasswords : public Relation
			{
				D3_CLASS_DECL(D3HistoricPasswords);

				protected:
					D3HistoricPasswords() {}

				public:
					class D3_API iterator : public Relation::iterator
					{
						public:
							iterator() {}
							iterator(const InstanceKeyPtrSetItr& itr) : Relation::iterator(itr) {}

							//! De-reference operator*()
							virtual D3HistoricPasswordPtr operator*();
							//! Assignment operator=()
							virtual iterator&           operator=(const iterator& itr);
					};

					//! front() method
					virtual D3HistoricPasswordPtr   front();
					//! back() method
					virtual D3HistoricPasswordPtr   back();
			};



		protected:
			D3UserBase() {}

		public:
			~D3UserBase() {}

			//! Create a new D3User
			static D3UserPtr                    CreateD3User(DatabasePtr pDB)		{ return (D3UserPtr) pDB->GetMetaDatabase()->GetMetaEntity(D3MDDB_D3User)->CreateInstance(pDB); }

			//! Return a collection of all instances of this
			static InstanceKeyPtrSetPtr					GetAll(DatabasePtr pDB);

			//! Load all instances of this
			static void													LoadAll(DatabasePtr pDB, bool bRefresh = false, bool bLazyFetch = true);

			//! Load a particular instance of this
			static D3UserPtr                    Load(DatabasePtr pDB, long lID, bool bRefresh = false, bool bLazyFetch = true);


			//! Load all D3RoleUsers objects. The objects loaded are of type D3RoleUser.
			virtual void												LoadAllD3RoleUsers(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation D3RoleUsers collection which contains objects of type D3RoleUser.
			virtual D3RoleUsers*                GetD3RoleUsers();
			//! Load all D3RowLevelPermissions objects. The objects loaded are of type D3RowLevelPermission.
			virtual void												LoadAllD3RowLevelPermissions(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation D3RowLevelPermissions collection which contains objects of type D3RowLevelPermission.
			virtual D3RowLevelPermissions*      GetD3RowLevelPermissions();
			//! Load all D3HistoricPasswords objects. The objects loaded are of type D3HistoricPassword.
			virtual void												LoadAllD3HistoricPasswords(bool bRefresh = false, bool bLazyFetch = true);
			//! Get the relation D3HistoricPasswords collection which contains objects of type D3HistoricPassword.
			virtual D3HistoricPasswords*        GetD3HistoricPasswords();

			/*! @name Get Column Values
			    \note These accessors do not throw even if the column's value is NULL.
			           Therefore, you should use these methods only if you're sure the
			           column's value is NOT NULL before using these.
			*/
			//@{
			//! ID
			virtual long                        GetID()                        { return Column(D3User_ID)->GetLong(); }
			//! Name
			virtual const std::string&          GetName()                      { return Column(D3User_Name)->GetString(); }
			//! Password
			virtual const Data&                 GetPassword()                  { return Column(D3User_Password)->GetData(); }
			//! Enabled
			virtual bool                        GetEnabled()                   { return Column(D3User_Enabled)->GetBool(); }
			//! WarehouseAreaAccessList
			virtual const std::string&          GetWarehouseAreaAccessList()   { return Column(D3User_WarehouseAreaAccessList)->GetString(); }
			//! CustomerAccessList
			virtual const std::string&          GetCustomerAccessList()        { return Column(D3User_CustomerAccessList)->GetString(); }
			//! TransmodeAccessList
			virtual const std::string&          GetTransmodeAccessList()       { return Column(D3User_TransmodeAccessList)->GetString(); }
			//! PWDAttempts
			virtual int                         GetPWDAttempts()               { return Column(D3User_PWDAttempts)->GetInt(); }
			//! PWDExpires
			virtual const D3Date&               GetPWDExpires()                { return Column(D3User_PWDExpires)->GetDate(); }
			//! Temporary
			virtual bool                        GetTemporary()                 { return Column(D3User_Temporary)->GetBool(); }
			//! Language
			virtual const std::string&          GetLanguage()                  { return Column(D3User_Language)->GetString(); }
			//@}

			/*! @name Set Column Values
			*/
			//@{
			//! Set ID
			virtual bool												SetID(long val)                { return Column(D3User_ID)->SetValue(val); }
			//! Set Name
			virtual bool												SetName(const std::string& val){ return Column(D3User_Name)->SetValue(val); }
			//! Set Password
			virtual bool												SetPassword(const Data& val)   { return Column(D3User_Password)->SetValue(val); }
			//! Set Enabled
			virtual bool												SetEnabled(bool val)           { return Column(D3User_Enabled)->SetValue(val); }
			//! Set WarehouseAreaAccessList
			virtual bool												SetWarehouseAreaAccessList(const std::string& val){ return Column(D3User_WarehouseAreaAccessList)->SetValue(val); }
			//! Set CustomerAccessList
			virtual bool												SetCustomerAccessList(const std::string& val){ return Column(D3User_CustomerAccessList)->SetValue(val); }
			//! Set TransmodeAccessList
			virtual bool												SetTransmodeAccessList(const std::string& val){ return Column(D3User_TransmodeAccessList)->SetValue(val); }
			//! Set PWDAttempts
			virtual bool												SetPWDAttempts(int val)        { return Column(D3User_PWDAttempts)->SetValue(val); }
			//! Set PWDExpires
			virtual bool												SetPWDExpires(const D3Date& val){ return Column(D3User_PWDExpires)->SetValue(val); }
			//! Set Temporary
			virtual bool												SetTemporary(bool val)         { return Column(D3User_Temporary)->SetValue(val); }
			//! Set Language
			virtual bool												SetLanguage(const std::string& val){ return Column(D3User_Language)->SetValue(val); }
			//@}

			//! A column accessor provided mainly for backwards compatibility
			virtual ColumnPtr										Column(D3User_Fields eCol){ return Entity::GetColumn((unsigned int) eCol); }
	};



} // end namespace D3


#endif /* INC_D3UserBase_H */
